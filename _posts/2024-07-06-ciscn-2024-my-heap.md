---
title: CISCN 2024 semi-final - An interesting heap exploitation by poisoning pthread_struct 
categories:
- ctf
- pwn
---

This is the first time when I have developed a heap exploitation on tcache. Even though a huge number of guys have agreed the difficulty in heap exploitation, I feel things are becoming way easier only if one has a solid understanding of heap and masters debugging. Not only does this post explains a solution, but also uncovers the pains that I went through while developing an exploit script. 


## Resolving the application logic
### Reversing the given binary and checking the version of libc

What one needs to do first is to reverse engineer the application logic of the given binary, and check the version of libc in order to tell available exploitation techniques from already patches vulnerabilities in old libc distributions. Load this binary into Ghidra. We could find that its logic is very typical because there are five functions, including add, delete, edit, and show. However, A function located at 0x101495 catches my attention, which I name as `print_shell_addr` in Ghidra, and it plays a big role in poisoning heap. Its decompiled code looks like the following:

```c
void print_shell_addr(void)
{
  printf("magic address: %p\n",get_shell);
  printf("edit data:");
  read(0,ptr_chunk,0x10);
  return;
}
void get_shell(void)
{
  system("/bin/sh");
  return;
}
```

Here, it is clear that the challenge designer would like us to store the address of get_shell somewhere else, and attempt to get it executed. Before we dive into auditing other basic functions, we need to check out the version of the given libc binary. As the preceeding result shown, the version is 2.35.

```bash
$ strings libc.so.6 | grep "ubuntu"
GNU C Library (Ubuntu GLIBC 2.35-0ubuntu3.7) stable release version 2.35.
<https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs>.
```

### Auditing 

Take a look at `menu`:
```
void menu(void)
{
  puts("magic heap has 4 choice : \nadd\ndelete\nshow\nedit");
  return;
}
```

Then turn to `add`:
```c
void add(void)
{
  int iVar1;
  
  puts("which one you choose?");
  iVar1 = choice();
  if (iVar1 == 1) {
    printf("size:");
    iVar1 = choice();
    ptr_chunk = (undefined *)malloc((long)iVar1);
  }
  else {
    malloc(0x4f0);
  }
  return;
}
```

This function allows users to allocate a chunk of specified size, and stores its pointer in a global variable `ptr_chunk`. Furthermore, I had no idea about the reason why `malloc(0x4f0);` serving non-one choices, has been put here while checking it firstly. However, this is very crucial and I will cover in later sections.

`delete` is easy to be understood:
```c
void del(void)
{
  free(ptr_chunk);
  puts("delete success!");
  return;
}
```

The `show` function does not print the content in the allocated buffer straightaway, but actually encodes it first then prints the encoded content. Nontheless, it is quite easy to decode and I will cover the decode algorithm in later sections when necessary.
```c
void show(void)
{
  long in_FS_OFFSET;
  uint data;
  int idx;
  if (ptr_chunk != (undefined *)0x0) {
    printf("the data:");
    for (idx = 0; idx < 7; idx = idx + 1) {
      data = idx + 0x99U ^ (int)(char)ptr_chunk[idx];
      write(1,&data,1);
    }
  }
  return;
}
```

Finally, check `edit`:
```
void edit(void)
{
  printf("edit data:");
  read(0,ptr_chunk,8);
  return;
}
```

It is worth to mention that only first 8 bytes are allowed to modify. 

### Vulnerabilities

As far as I audit in the previous section, there is a relatively obvious vulnerability - use after free (UAF) and double free. In other words, one could allocate a heap buffer then modify its first 8 bytes after freeing the buffer. Moreover, this version of libc has enabled tcache to facilitate heap management in each thread without a need of mixing allocated chunks of other threads at the same management namespace.

Allocate a chunk of size 24 bytes, then free it:
```
magic heap has 4 choice : 
add
delete
show
edit
1
which one you choose?
1
size:24
magic heap has 4 choice : 
add
delete
show
edit
2
delete success!
pwndbg> bins
tcachebins
0x20 [  1]: 0x55555555b2a0 ◂— 0x0
fastbins
empty
unsortedbin
empty
smallbins
empty
largebins
empty
```

It could be seen in a way that our previously allocated chunk has been placed into a bin of size 0x20 in tcache. Furthermore, being able to modify first 16 bytes in a freed chunk allows us to accomplish double free on tcache.

By referring to another [write-up](https://bbs.kanxue.com/thread-282156.htm), the author claimed there are many approaches to exploit in libc 2.35 and only achieved exploitation by overwriting a return address at the stack to intercept control flow to get a shell. This post will also use the same approach with a slightly different implementation.

## Leaking essential addresses

### Leaking heap

### Leaking libc


## Modifying pthread_struct

## Taking over execution flow

